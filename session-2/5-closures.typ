#import "../template.typ": *

= Closures

== Syntax

#slide[

  #info[
    Closures are anonymous functions that can capture variables from their surrounding scope.
  ]


  ```rs
    fn main() {
      // Argument and return type can be inferred for lightweight syntax:
      let double_it = |n| n * 2;
      dbg!(double_it(50));

      // Or we can specify types and bracket the body to be fully explicit:
      let add_1f32 = |x: f32| -> f32 { x + 1.0 };
      dbg!(add_1f32(50.));
  }
  ```

  Properties:
  #pause
  - The body may be be surrounded by `{ .. }`
  #pause
  - Argument and return types are optional, and are inferred if not given.
]

== Capturing

#grid(columns: 2, column-gutter: 4em)[```rust
fn main() {
    let max_value = 5;
    let clamp = |v| {
        if v > max_value { max_value } else { v }
    };

    dbg!(clamp(1));
    dbg!(clamp(3));
    dbg!(clamp(5));
    dbg!(clamp(7));
    dbg!(clamp(10));
}
```][
  By default, a closure captures values by reference. Here max_value is captured by clamp, but still available to main for printing.

  #qa[Try making max_value mutable, changing it, and printing the clamped values again. Why doesn't this work?][The closure captures by reference. No mutable borrow may coexist with an immutable borrow.]]

#slide[
  === Mutable capture

  #grid(columns: 2, column-gutter: 4em)[```rust
  fn main() {
      let mut max_value = 5;
      let mut clamp = |v| {
          max_value += 1;
          if v > max_value { max_value } else { v }
      };

      dbg!(clamp(1));
      dbg!(clamp(3));
      dbg!(clamp(5));
      dbg!(clamp(7));
      dbg!(clamp(10));
  }
  ```][
    If a closure mutates captured values, it captures them by mutable reference.

    #pause

    #qa[Why does the closure need to be `mut`?][The closure's internal state changes, so it must be declared mutable.]

    #pause

    #qa[What happens if you try to access `max_value` directly while the closure exists?][Compile error: the closure holds a mutable borrow, preventing other accesses.]
  ]
]


== Moving

#slide[
  === Move closures

  #grid(columns: 2, column-gutter: 4em)[```rust
  fn main() {
      let name = String::from("Alice");
      let greet = move || {
          println!("Hello, {}", name);
      };

      greet();
      greet();

      // println!("{}", name); // Error!
  }
  ```][
    The `move` keyword forces a closure to take ownership of captured values.

    #pause

    #qa[What happens if you uncomment the last line?][Compile error: `name` was moved into the closure and can no longer be used.]

    #pause

    #qa[Why can we call `greet()` multiple times?][The closure owns `name`, which implements `Clone`, so it can be called repeatedly.]
  ]

  #pause

  Common use case: passing closures to threads or async tasks that must outlive their parent scope.
]

== Internal representation of closures

#slide[
  #set text(size: 0.8em)
  Closures are like structs with a function field:

  1. Each captured variable is a reference field.
  2. The closure body is a method that uses these fields.

  For example, the closure `|x| x + offset` where `offset` is captured from the environment is represented as:

  ```rs
  struct Closure {
      offset: &i32,
  }

  impl Closure {
      fn call(&self, x: i32) -> i32 {
          x + *self.offset
      }
  }
  ```
  #pause
  #warning[This *representation is hidden*.]


  Closures belong to the category of *anonymous types*. Each closure has a unique, unnamed type generated by the compiler.
]


== Closure traits

#slide[




  Please open demo file `session-2/examples/s2e5-closure-traits.rs`.
]

#slide[
  #set text(size: 0.9em)

  #grid(columns: (1fr, 1fr), column-gutter: 2em)[
    Closures have anonymous types that implement one or more of these traits:

    #pause

    #fletcher-diagram(
      spacing: (2em, 2.5em),
      node((0, 2), [`FnOnce`], name: <once>, fill: red.lighten(70%)),
      node((0, 1), [`FnMut`], name: <mut>, fill: orange.lighten(70%)),
      node((0, 0), [`Fn`], name: <fn>, fill: green.lighten(70%)),
      edge(<mut>, <once>, "->"),
      edge(<fn>, <mut>, "->"),
    )

    #pause

    Trait hierarchy in Rust stdlib:
    ```rs
    trait FnOnce { /* ... */ }
    trait FnMut: FnOnce { /* ... */ }
    trait Fn: FnMut { /* ... */ }
    ```
  ][
    - *`Fn`*: Immutable capture, callable multiple times, even concurrently
    - *`FnMut`*: Mutable capture, callable multiple times, not concurrently
    - *`FnOnce`*: Ownership capture, callable once, consumes closure

    #pause

    #qa[Can a closure implementing `Fn` be used where `FnOnce` is required?][Yes. `Fn` is a subtrait of `FnMut`, which is a subtrait of `FnOnce`.]

    #pause

    #qa[What does the `:` in `trait Fn: FnMut` mean?][`Fn` is a subtrait of `FnMut`, meaning anything implementing `Fn` must also implement `FnMut`.]
  ]

  #pause

  #info[All `Fn` closures are also `FnMut` and `FnOnce`. All `FnMut` closures are also `FnOnce`.]
]

== Picking the right closure trait

#slide[

  #grid(columns: (1fr, 1fr), column-gutter: 3em)[
    *When accepting closures*

    Prefer the least restrictive trait:

    1. `FnOnce` - called once (most flexible)
    2. `FnMut` - called multiple times, may mutate
    3. `Fn` - called multiple times, no mutation

    #pause

    #fletcher-diagram(
      spacing: (1em, 2em),
      node((0, 0), [`FnOnce`], name: <once>, fill: green.lighten(70%)),
      node((0, 1), [`FnMut`], name: <mut>, fill: orange.lighten(70%)),
      node((0, 2), [`Fn`], name: <fn>, fill: red.lighten(70%)),
      edge(<mut>, <once>, "->", label: [is a subtrait of]),
      edge(<fn>, <mut>, "->", label: [is a subtrait of]),
    )

    Maximizes caller flexibility
  ][
    *When providing closures*

    Prefer the most restrictive trait:

    1. `Fn` - most flexible (most usable)
    2. `FnMut` - medium flexibility
    3. `FnOnce` - least flexible

    #pause

    #fletcher-diagram(
      spacing: (1em, 2em),
      node((0, 0), [`Fn`], name: <fn2>, fill: green.lighten(70%)),
      node((0, 1), [`FnMut`], name: <mut2>, fill: orange.lighten(70%)),
      node((0, 2), [`FnOnce`], name: <once2>, fill: red.lighten(70%)),
      edge(<fn2>, <mut2>, "->", label: [accepted as argument]),
      edge(<mut2>, <once2>, "->", label: [accepted as argument]),
    )

    Maximizes usage flexibility
  ]

  #pause

  #info[`Fn` closures can be used wherever `FnMut` or `FnOnce` is expected.]
]


== Auto-traits of closures

#slide[

  #qa[What are auto-traits?][Traits that the compiler can automatically implement for types based on their structure.]

  Closures automatically implement `Copy` and `Clone` based on captured values:

  #pause

  #fletcher-diagram(
    spacing: (3em, 2em),
    node((0, 0), [Closure], name: <closure>, fill: blue.lighten(70%)),
    node((-1, -1), [Captures\ `Copy` values], name: <copy-cap>, fill: green.lighten(70%)),
    node((1, -1), [Captures\ `Clone` values], name: <clone-cap>, fill: orange.lighten(70%)),
    edge(<copy-cap>, <closure>, "->"),
    edge(<clone-cap>, <closure>, "->"),
    pause,
    node((-1, 1), [`impl Copy`], name: <copy-impl>),
    node((1, 1), [`impl Clone`], name: <clone-impl>),
    edge(<closure>, <copy-impl>, "->", label: [infers]),
    edge(<closure>, <clone-impl>, "->", label: [infers]),
  )

  #pause



  #info[Closures inherit properties from the values they capture.]
]


== Exercise

Please find the statement of the exercise at `session-2/examples/s2d6-closures.rs` in this repo.

Run it with `cargo run --example s2d6-closures`.
