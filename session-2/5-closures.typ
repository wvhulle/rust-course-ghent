#import "../template.typ": *

= Closures

#focus-slide[
  #image("images/scheme.png")
]

== Syntax

#slide[

  #info(title: [Closures])[
    Anonymous functions that can capture variables from their surrounding scope.
  ]


  ```rs
    fn main() {
      // Argument and return type can be inferred for lightweight syntax:
      let double_it = |n| n * 2;
      dbg!(double_it(50));

      // Or we can specify types and bracket the body to be fully explicit:
      let add_1f32 = |x: f32| -> f32 { x + 1.0 };
      dbg!(add_1f32(50.));
  }
  ```

  #pause
  - The body may be be surrounded by `{ .. }`
  #pause
  - Argument and return types are optional, and are inferred if not given.
]

== Capturing

=== Immutable capture

#grid(columns: 2, column-gutter: 4em)[```rust
fn main() {
    let max_value = 5;
    let clamp = |v| {
        if v > max_value { max_value } else { v }
    };

    dbg!(clamp(1));
    dbg!(clamp(3));
    dbg!(clamp(5));
    dbg!(clamp(7));
}
```][
  By default, a closure captures values by immutable reference. Here `max_value`is captured by clamp, but still available to main for printing.

  #qa[Try making max_value mutable, changing it, and printing the clamped values again. Why doesn't this work?][The closure captures by reference. No mutable borrow may coexist with an immutable borrow.]]

#slide[
  === Mutable capture

  #grid(columns: 2, column-gutter: 4em)[

    #codly(
      highlights: (
        (line: 3, start: 9, end: 11, fill: red),
      ),
    )
    ```rust
    fn main() {
        let mut max_value = 5;
        let mut clamp = |v| {
            max_value += 1;
            if v > max_value { max_value } else { v }
        };

        dbg!(clamp(1));
        dbg!(clamp(3));
        dbg!(clamp(5));
        dbg!(clamp(7));
        dbg!(clamp(10));
    }
    ```][
    If a closure mutates captured values, it captures them by mutable reference.

    #pause

    #qa[Why does the closure need to be `mut`?][The closure's internal state changes, so it must be declared mutable.]

    #pause

    #qa[What happens if you try to access `max_value` directly while the closure exists?][Compile error: the closure holds a mutable borrow, preventing other accesses.]
  ]
]


== Moving

#slide[
  === Move closures

  #grid(columns: 2, column-gutter: 4em)[

    #codly(
      highlights: (
        (line: 3, start: 17, end: 20, fill: red),
      ),
    )
    ```rust
    fn main() {
        let name = String::from("Alice");
        let greet = move || {
            println!("Hello, {}", name);
        };

        greet();
        greet();

        // println!("{}", name); // Error!
    }
    ```][
    The `move` keyword forces a closure to take ownership of captured values.

    #pause

    #qa[What happens if you uncomment the last line?][Compile error: `name` was moved into the closure and can no longer be used.]

    #pause

    #qa[Why can we call `greet()` multiple times?][The closure owns `name`, which implements `Clone`, so it can be called repeatedly.]
  ]

  #pause

  Common use case: passing closures to threads or async tasks that must outlive their parent scope.
]

== Internal representation of closures

#slide[
  #set text(size: 0.8em)

  #qa[What category of types do closures belong to?][*anonymous types*. Each closure has a unique, unnamed type generated by the compiler.]

  Closures are like structs with a function field:

  1. Each captured variable is a reference field.
  2. The closure body is a method that uses these fields.

  For example, the closure `|x| x + offset` where `offset` is captured from the environment is represented as:

  #codly(
    highlights: (
      (line: 6, start: 13, end: 17, fill: red),
    ),
  )
  ```rs
  struct Closure {
      offset: &i32,
  }

  impl Closure {
      fn call(&self, x: i32) -> i32 {
          x + *self.offset
      }
  }
  ```
  #pause
  #warning[The thing that sets closures apart is the hidden signature of the `call` method (whether it takes `&self` or not).]



]

== Datastructures containing functions

#slide[
  #set text(size: 0.9em)
  To store a closure in a data structure, we need to turn the anonymous closure type into generic type variable.

  ```rust
  struct Processor<F> {
      field: i32
      func: F,
  }

  impl<F> Processor<F>
  where
      F: Fn(i32) -> i32,
  {
      fn process(&self) -> i32 {
          (self.func)(self.field)
      }
  }
  ```


][

  #qa[What does `Fn(i32) -> i32` mean here?][It's an *`Fn`-trait bound* (function trait bound) indicating that `F` must be a type that implements the `Fn` trait.
  ]


  *Always use generic `Fn` trait bounds for structs containing functions*.

  #pause

  #warning[Do not turn your closure into a *function pointer* (`fn` type), even when the compiler suggests it!]

  #qa[Why are function pointers bad?][May need heap allocation. Cannot capture variables.]
]

#focus-slide[
  #image("images/dark_magic.jpg")
]

== Closure traits

#slide[




  Please open demo file `session-2/examples/s2e5-closure-traits.rs` and play around with the code.
]

#slide[
  #set text(size: 0.9em)


  Closures have anonymous types that implement one or more of these traits:

  #pause

  #fletcher-diagram(
    spacing: (2em, 4em),
    node((0, 2), [`FnOnce`], name: <once>, fill: red.lighten(70%)),
    node((1, 2), [`fn call(self)`]),
    node((2, 2), [`trait FnOnce`], name: <once-descr>),
    node((3, 2), [callable once], name: <once-props>),
    node(enclose: (<once>, <once-props>, <once-descr>), fill: red.lighten(90%)),
    pause,
    node((0, 1), [`FnMut`], name: <mut>, fill: orange.lighten(70%)),
    node((1, 1), [`fn call(&mut self)`]),
    node((2, 1), [`trait FnMut: FnOnce`], name: <mut-props>),
    node((3, 1), [ can mutate captures], name: <mut-descr>),
    node(enclose: (<mut>, <mut-props>, <mut-descr>), fill: orange.lighten(90%)),
    edge(<mut>, <once>, "->", label: [implements]),

    pause,
    node((0, 0), [`Fn`], name: <fn>, fill: green.lighten(70%)),
    node((1, 0), [`fn call(&self)`]),
    node((2, 0), [`trait Fn: FnMut`], name: <fn-props>),
    node((3, 0), [cannot mutate captures], name: <fn-descr>),
    node(enclose: (<fn>, <fn-props>, <fn-descr>), fill: green.lighten(90%)),
    edge(<fn>, <mut>, "->", label: [implements]),
  )

  #pause

  #info[Trait hierarchy: `Fn` implements `FnMut`, `FnMut` implements `FnOnce`. A closure callable with `&self` can also be called with `&mut self` or `self`.]

  #pause

  #qa[Can a closure implementing `Fn` be used where `FnOnce` is required?][Yes. `Fn` is a subtrait of `FnMut`, which is a subtrait of `FnOnce`.]



]

#focus-slide[
  #image("images/coin.jpg", width: 100%)
]

== Picking the right closure trait

#slide[
  #set text(size: 0.85em)

  *You define a function accepting a closure* (a higher-order function)

  #qa[Which closure trait should use as a generic type trait bound?][Prefer `FnOnce` (accepts any closure type).]

  #qa[Why?][`Fn` and `FnMut` both implement `FnOnce`, so all closures can be passed. Most flexible for callers.]

  #pause

  ```rust
  fn apply_once<F: FnOnce(i32) -> i32>(f: F, value: i32) -> i32 {
      f(value)
  }

  fn main() {
      apply_once(|n| n + 1, 5);        // Fn works
      apply_once(move |n| n * 2, 5);   // FnOnce works
  }
  ```
]

#slide[
  #set text(size: 0.85em)

  *You have to provide a closure for someone else's higher-order function*

  #qa[Which closure trait should your closure implement?][Aim for `Fn` if possible, fall back to `FnMut` or `FnOnce` if needed.]

  #qa[Why?][`Fn` closures work wherever `FnMut` or `FnOnce` is required, giving maximum usability.\ Think of receiver types: `&self` (`Fn`) works where `&mut self` (`FnMut`) or `self` (`FnOnce`) is needed.]


  #pause

  ```rust
  fn process<F: Fn(i32) -> i32>(items: &[i32], f: F) {
      for item in items {
          println!("{}", f(*item));  // Requires Fn: called multiple times
      }
  }

  fn main() {
      process(&[1, 2, 3], |x| x * 2);  // Fn: OK (no mutation)
      // let mut c = 0;
      // process(&[1, 2, 3], |x| { c += 1; x });  // FnMut: Error!
  }
  ```
]


== Auto-traits of closures

#focus-slide[
  #image("images/flamingo.jpg")
]

#slide[

  #qa[What are auto-traits?][Traits that the compiler can automatically implement for types based on their structure.]

  Closures automatically implement `Copy` and `Clone` based on captured values:

  #pause
  #set align(center)
  #fletcher-diagram(
    spacing: (4em, 2em),
    node((0, -1), [`let x = String::from("data");`], name: <var>, fill: green.lighten(90%)),
    node((0, 0), [`let f = move || { x.clone() };`], name: <closure>, fill: blue.lighten(70%)),
    edge(<var>, <closure>, "->", label: [captures]),
    pause,
    node((0, 1), [`f` implements `Clone`], name: <clone-impl>, fill: orange.lighten(70%)),
    edge(<closure>, <clone-impl>, "->", label: [auto-trait]),
    pause,
    node((0, 2), [Can be cloned: `let g = f.clone();`], name: <usage>),
    edge(<clone-impl>, <usage>, "->"),
  )

  #pause



  #info[Closures inherit properties from the values they capture.]
]


== Exercise

Please find the statement of the exercise at `session-2/examples/s2d6-closures.rs` in this repo.

Run it with `cargo run --example s2d6-closures`.
